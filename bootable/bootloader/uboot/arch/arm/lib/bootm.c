/*
 * (C) Copyright 2002
 * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
 * Marius Groeger <mgroeger@sysgo.de>
 *
 * Copyright (C) 2001  Erik Mouw (J.A.K.Mouw@its.tudelft.nl)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
 *
 */

#include <common.h>
#include <command.h>
#include <image.h>
#include <u-boot/zlib.h>
#include <asm/byteorder.h>

#if defined(MT6516)
  #include "asm/arch/mt6516.h"
  #include "mt6516_partition.h"
  #include <asm/arch/mt6516_image.h>
  #include <asm/arch/mt6516_mode.h>
  #ifdef CFG_META_MODE
    #include <asm/arch/mt6516_meta.h>
  #endif
#else
  #include "asm/arch/mt65xx.h"
  #include "mt65xx_partition.h"
  #include <asm/arch/boot_mode.h>
  #include <asm/arch/mt65xx_image.h>
  #ifdef CFG_META_MODE
    #include <asm/arch/mt65xx_meta.h>
  #endif
#endif

#include <version_autogenerated.h>

#if defined(CFG_NAND_BOOT)
extern unsigned int     nand_flash_man_code;
extern unsigned int     nand_flash_dev_id;

#define     NAND_MANF_CMDLINE   " nand_manf_id=0x"
#define     NAND_DEV_CMDLINE    " nand_dev_id=0x"
#endif


//*********
//* Notice : it's kernel start addr (and not include any debug header)
extern unsigned int g_kmem_off;

//*********
//* Notice : it's rootfs start addr (and not include any debug header)
extern unsigned int g_rmem_off;
extern unsigned int g_rimg_sz;

DECLARE_GLOBAL_DATA_PTR;

#if defined (CONFIG_SETUP_MEMORY_TAGS) || \
    defined (CONFIG_CMDLINE_TAG) || \
    defined (CONFIG_INITRD_TAG) || \
    defined (CONFIG_SERIAL_TAG) || \
    defined (CONFIG_REVISION_TAG) || \
    defined (CONFIG_VFD) || \
    defined (CONFIG_LCD)
static void setup_start_tag (bd_t *bd);

# ifdef CONFIG_SETUP_MEMORY_TAGS
static void setup_memory_tags (bd_t *bd);
static void setup_memory_tags_factory (bd_t *bd);
# endif
static void setup_commandline_tag (bd_t *bd, char *commandline);

# ifdef CONFIG_INITRD_TAG
static void setup_initrd_tag (bd_t *bd, ulong initrd_start,
			      ulong initrd_end);
# endif
static void setup_end_tag (bd_t *bd);

# if CONFIG_VIDEOLFB_TAG
static void setup_videolfb_tag (gd_t *gd);
# endif

static struct tag *params;
#endif /* CONFIG_SETUP_MEMORY_TAGS || CONFIG_CMDLINE_TAG || CONFIG_INITRD_TAG */

#if 0
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
	bd_t	*bd = gd->bd;
	char	*s;
	int	machid = bd->bi_arch_number;
	void	(*theKernel)(int zero, int arch, uint params);

#ifdef CONFIG_CMDLINE_TAG
	char *commandline = getenv ("bootargs");
#endif

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
		return 1;

	theKernel = (void (*)(int, int, uint))images->ep;

	s = getenv ("machid");
	if (s) {
		machid = simple_strtoul (s, NULL, 16);
		printf ("Using machid 0x%x from environment\n", machid);
	}

	show_boot_progress (15);

	debug ("## Transferring control to Linux (at address %08lx) ...\n",
	       (ulong) theKernel);

#if defined (CONFIG_SETUP_MEMORY_TAGS) || \
    defined (CONFIG_CMDLINE_TAG) || \
    defined (CONFIG_INITRD_TAG) || \
    defined (CONFIG_SERIAL_TAG) || \
    defined (CONFIG_REVISION_TAG) || \
    defined (CONFIG_LCD) || \
    defined (CONFIG_VFD)
	setup_start_tag (bd);
#ifdef CONFIG_SERIAL_TAG
	setup_serial_tag (&params);
#endif
#ifdef CONFIG_REVISION_TAG
	setup_revision_tag (&params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
	setup_memory_tags (bd);
#endif
#ifdef CONFIG_CMDLINE_TAG
	setup_commandline_tag (bd, commandline);
#endif
#ifdef CONFIG_INITRD_TAG
	if (images->rd_start && images->rd_end)
		setup_initrd_tag (bd, images->rd_start, images->rd_end);
#endif
#if CONFIG_VIDEOLFB_TAG
	setup_videolfb_tag ((gd_t *) gd);
#endif
	setup_end_tag (bd);
#endif

	/* we assume that the kernel is in place */
	printf ("\nStarting kernel ...\n\n");

#ifdef CONFIG_USB_DEVICE
	{
		extern void udc_disconnect (void);
		udc_disconnect ();
	}
#endif

	cleanup_before_linux ();

	theKernel (0, machid, bd->bi_boot_params);
	/* does not return */

	return 1;
}
#endif

void msg_header_error(char *img_name)
{
	printf ("[MBOOT] Load '%s' partition Error\n", img_name);
	printf("\n*******************************************************\n");
	printf("ERROR.ERROR.ERROR.ERROR.ERROR.ERROR.ERROR.ERROR.ERROR\n");
	printf("*******************************************************\n");
	printf("> If you use NAND boot\n");
	printf("> (1) %s is wrong !!!! \n", img_name);        
	printf("> (2) please make sure the image you've downloaded is correct\n");
	printf("\n> If you use MSDC boot\n");
	printf("> (1) %s is not founded in SD card !!!! \n",img_name);       
	printf("> (2) please make sure the image is put in SD card\n");
	printf("*******************************************************\n");        
	printf("ERROR.ERROR.ERROR.ERROR.ERROR.ERROR.ERROR.ERROR.ERROR\n");
	printf("*******************************************************\n");        
	while(1);
}

void msg_img_error(char *img_name)
{
	printf ("[MBOOT] Load '%s' partition Error\n", img_name);
	printf("\n*******************************************************\n");
	printf("ERROR.ERROR.ERROR.ERROR.ERROR.ERROR.ERROR.ERROR.ERROR\n");
	printf("*******************************************************\n");
	printf("> Please check kernel and rootfs in %s are both correct.\n",img_name);
	printf("*******************************************************\n");        
	printf("ERROR.ERROR.ERROR.ERROR.ERROR.ERROR.ERROR.ERROR.ERROR\n");
	printf("*******************************************************\n");        
	while(1);
}

/**********************************************************
 * Routine: do_msdc_boot
 *
 * Description: main function to load image from msdc
 *
 **********************************************************/
#ifdef CFG_MMC_BOOT
int do_msdc_boot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
  /*Add MSDC boot codes here*/
	do_nand_boot(cmdtp, flag, argc, argv);
}
#endif 


/**********************************************************
 * Routine: do_nand_boot
 *
 * Description: main function to load image from nand flash
 *
 **********************************************************/
/* Hong-Rong add for porting, fix me in Makefile */
#define BUILD_VERSION_CLI "MAIN2.2"
#define UBOOT_VERSION_CLI "2010.06" 

extern BOOT_ARGUMENT *g_boot_arg;
int do_nand_boot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	DECLARE_GLOBAL_DATA_PTR;
	int ret;
	bd_t *bd = gd->bd;
	ulong addr, data, len, initrd_start, initrd_end;
    void (*theKernel)(int zero, int arch, uint params);
    int strlen;


#ifdef CONFIG_CMDLINE_TAG
    char *commandline = getenv ("bootargs");
#endif

#ifdef CFG_UBOOT_PROFILING
      extern unsigned int boot_time;
      unsigned int time_do_nand_boot= get_timer(0);
      unsigned int time_rootfs;
      unsigned int time_load_bootimg;
      unsigned int ubt;
#endif


#if defined (CONFIG_SETUP_MEMORY_TAGS) || \
    defined (CONFIG_CMDLINE_TAG) || \
    defined (CONFIG_INITRD_TAG) || \
    defined (CONFIG_SERIAL_TAG) || \
    defined (CONFIG_REVISION_TAG) || \
    defined (CONFIG_LCD) || \
    defined (CONFIG_VFD)
	setup_start_tag (bd);
#ifdef CONFIG_SERIAL_TAG
	setup_serial_tag (&params);
#endif
#ifdef CONFIG_REVISION_TAG
	setup_revision_tag (&params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
	if(g_boot_mode == FACTORY_BOOT)
	{
	  setup_memory_tags_factory(bd);
	}
	else
	{
	  setup_memory_tags(bd);
	}  
#endif

//#ifdef CONFIG_CMDLINE_TAG
	//****************
	//* according to current boot mode to set boot tag and related boot args
	//*
	switch(g_boot_mode)
	{
		//********************************************************************
		//* NORMAL BOOT
		//********************************************************************		
		case NORMAL_BOOT:
#if defined(CFG_NAND_BOOT)
      strlen += sprintf(commandline, "%s%s%x%s%x", 
                commandline, NAND_MANF_CMDLINE, nand_flash_man_code, NAND_DEV_CMDLINE, nand_flash_dev_id);
#endif

	  setup_boot_tag(NORMAL_BOOT);

      ret = mboot_android_load_bootimg_hdr(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);            
      if (ret < 0) {
			 	msg_header_error("Android Boot Image");
      }
      
#ifdef CFG_UBOOT_PROFILING
      time_load_bootimg= get_timer(0);
#endif      
      ret = mboot_android_load_bootimg(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);            
#ifdef CFG_UBOOT_PROFILING
        printf("[PROFILE] ------- load boot.img takes %d ms -------- \n", get_timer(time_load_bootimg));
#endif

      if (ret < 0) {
	  		msg_img_error("Android Boot Image");
      }          
			break;

		//********************************************************************
		//* META
		//********************************************************************		
		case META_BOOT:
		#ifdef CFG_META_MODE
			//printf("[META] - Old bootargs : %s\n",commandline);		
			//commandline=strcat(commandline,META_BOOTARGS);
			//printf("[META] - New bootargs : %s\n",commandline);	
			setup_boot_tag(META_BOOT);
          setup_meta_com_tag(g_boot_arg->meta_com_type, g_boot_arg->meta_com_id);
		#endif
      ret = mboot_android_load_bootimg_hdr(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);            
      if (ret < 0) {
			  msg_header_error("Android Boot Image");
      }
      ret = mboot_android_load_bootimg(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);            
      if (ret < 0) {
		    msg_img_error("Android Boot Image");
      }            
			break;						

      //********************************************************************
      //* ADVANCED META MODE
	  //********************************************************************
	  case ADVMETA_BOOT:
        //printf("[META] - Old bootargs : %s\n",commandline);
        //commandline=strcat(commandline, ADV_META_BOOTARGS);
        //printf("[META] - New bootargs : %s\n",commandline);	
        setup_boot_tag(ADVMETA_BOOT);
        setup_meta_com_tag(g_boot_arg->meta_com_type, g_boot_arg->meta_com_id);
        ret = mboot_android_load_bootimg_hdr(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);            
        if (ret < 0) {
			  msg_header_error("Android Boot Image");
        }
        ret = mboot_android_load_bootimg(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);            
        if (ret < 0) {
		  msg_img_error("Android Boot Image");
        }
      break;
      
		//********************************************************************
		//* ANDROID RECOVERY
		//********************************************************************		
		case RECOVERY_BOOT:
			#ifdef CFG_RECOVERY_MODE
				setup_boot_tag(RECOVERY_BOOT);
			#endif	
        ret = mboot_android_load_recoveryimg_hdr(PART_RECOVERY, CFG_BOOTIMG_LOAD_ADDR);            
        if (ret < 0) {
			  	msg_header_error("Android Recovery Image");
        }   
        ret = mboot_android_load_recoveryimg(PART_RECOVERY, CFG_BOOTIMG_LOAD_ADDR);            
        if (ret < 0) {
			  	msg_img_error("Android Recovery Image");
        }
			break;

		//********************************************************************
		//* FACTORY
		//********************************************************************
		case FACTORY_BOOT:
      #if defined(CFG_NAND_BOOT)
      strlen += sprintf(commandline, "%s%s%x%s%x", 
                commandline, NAND_MANF_CMDLINE, nand_flash_man_code, NAND_DEV_CMDLINE, nand_flash_dev_id);
      #endif
      
			#ifdef CFG_FACTORY_MODE
				setup_boot_tag(FACTORY_BOOT);
			#endif

      //*************
      //* parse recovery image header
      //* 
      ret = mboot_android_load_factoryimg_hdr(CFG_FACTORY_NAME, CFG_BOOTIMG_LOAD_ADDR);
            
      if (ret < 0) {
				printf("factory image doesn't exist in SD card\n");	
			  // load boot image from nand
	      ret = mboot_android_load_bootimg_hdr(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);            
	      if (ret < 0) {
				  msg_header_error("Android Boot Image");
	      }            
	      ret = mboot_android_load_bootimg(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);            
        if (ret < 0) {
					msg_img_error("Android Boot Image");
	      }          
      }            
      else
      {	
	    // load the factory image
	      ret = mboot_android_load_factoryimg(CFG_FACTORY_NAME, CFG_BOOTIMG_LOAD_ADDR);            
    	  if (ret < 0) {
				  msg_img_error("Android Factory Image");
        }
      }
			break;			
		//********************************************************************
		//* ATE_FACTORY_BOOT
		//********************************************************************
		case ATE_FACTORY_BOOT:
      #if defined(CFG_NAND_BOOT)
      strlen += sprintf(commandline, "%s%s%x%s%x", 
                commandline, NAND_MANF_CMDLINE, nand_flash_man_code, NAND_DEV_CMDLINE, nand_flash_dev_id);
      #endif
      
			#ifdef CFG_FACTORY_MODE
				setup_boot_tag(ATE_FACTORY_BOOT);
			#endif

      //*************
      //* parse recovery image header
      //* 
      ret = mboot_android_load_factoryimg_hdr(CFG_FACTORY_NAME, CFG_BOOTIMG_LOAD_ADDR);
            
      if (ret < 0) {
				printf("factory image doesn't exist in SD card\n");	
			  // load boot image from nand
	      ret = mboot_android_load_bootimg_hdr(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);            
	      if (ret < 0) {
				  msg_header_error("Android Boot Image");
	      }            
	      ret = mboot_android_load_bootimg(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);            
        if (ret < 0) {
					msg_img_error("Android Boot Image");
	      }          
      }            
      else
      {	
	    // load the factory image
	      ret = mboot_android_load_factoryimg(CFG_FACTORY_NAME, CFG_BOOTIMG_LOAD_ADDR);            
    	  if (ret < 0) {
				  msg_img_error("Android Factory Image");
        }
      }
			break;		
		//********************************************************************
		//* SW BOOT
		//********************************************************************		
		case SW_REBOOT:
			setup_boot_tag(SW_REBOOT);
      ret = mboot_android_load_bootimg_hdr(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);          
      if (ret < 0) {
			  msg_header_error("Android Boot Image");
      }
      ret = mboot_android_load_bootimg(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);            
      if (ret < 0) {
			  msg_img_error("Android Boot Image");
      }       
			break;        
		//********************************************************************
		//* ALARM BOOT
		//********************************************************************		
		case ALARM_BOOT:
#if defined(CFG_NAND_BOOT)
      strlen += sprintf(commandline, "%s%s%x%s%x", 
                commandline, NAND_MANF_CMDLINE, nand_flash_man_code, NAND_DEV_CMDLINE, nand_flash_dev_id);
#endif

	  setup_boot_tag(ALARM_BOOT);

      ret = mboot_android_load_bootimg_hdr(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);            
      if (ret < 0) {
			 	msg_header_error("Android Boot Image");
      }
      
#ifdef CFG_UBOOT_PROFILING
      time_load_bootimg= get_timer(0);
#endif      
      ret = mboot_android_load_bootimg(PART_BOOTIMG, CFG_BOOTIMG_LOAD_ADDR);            
#ifdef CFG_UBOOT_PROFILING
        printf("[PROFILE] ------- load boot.img takes %d ms -------- \n", get_timer(time_load_bootimg));
#endif

      if (ret < 0) {
	  		msg_img_error("Android Boot Image");
      }          
			break;	    
	}

//*************
//* relocate rootfs (ignore rootfs header)
//*
#ifdef CFG_UBOOT_PROFILING
    time_rootfs = get_timer(0);
#endif
    //if(g_boot_mode == RECOVERY_BOOT)
    //{
      memcpy((char *)CFG_RAMDISK_LOAD_ADDR, (char *)(g_rmem_off), g_rimg_sz);
    //}
    g_rmem_off = CFG_RAMDISK_LOAD_ADDR;
#ifdef CFG_UBOOT_PROFILING
    printf("[PROFILE] ------- reloate rootfs takes %d ms -------- \n", get_timer(time_rootfs));
#endif
    
          strlen += sprintf(commandline, "%s%s%s",
                                      commandline, 
                                      " uboot_ver=" UBOOT_VERSION_CLI,
                                      " uboot_build_ver=" BUILD_VERSION_CLI
                                      );
#ifdef CFG_UBOOT_PROFILING
        ubt = ((unsigned int)get_timer(boot_time)) + 810;
        strlen += sprintf(commandline, "%s%s%d", commandline, ".ubt.", ubt);
#endif    

    /**
     * The function "custom_port_in_kernel" is used to modify UART port acorrding different requirement. 
     * It may change ttyMT3 to ttyMT0. This function is implemented at uart.c. 
     */
    custom_port_in_kernel(g_boot_mode, commandline);

	strlen += sprintf(commandline, "%s lcm=%1d-%s", commandline, DISP_IsLcmFound(), mt65xx_disp_get_lcm_id());
	strlen += sprintf(commandline, "%s fps=%1d", commandline, mt65xx_disp_get_lcd_time());
    
	setup_commandline_tag (bd, commandline);
  
//#endif //CONFIG_CMDLINE_TAG

//*************
//* dump some starting instruction for debug
//* 
//printf(" theKernel (0x%x)\n",g_kmem_off);
//printf(" theKernel (0x%x) = 0x%x\n",g_kmem_off,DRV_Reg32(g_kmem_off));
//printf(" theKernel (0x%x) = 0x%x\n",g_kmem_off+0x4,DRV_Reg32(g_kmem_off+0x4));
//printf(" theKernel (0x%x) = 0x%x\n",g_kmem_off+0x8,DRV_Reg32(g_kmem_off+0x8));  



//*************
//* dump some starting instruction for debug
//* 
//printf("\n rootfs (0x%x)\n",g_rmem_off);
//printf(" rootfs (0x%x) = 0x%x\n",g_rmem_off,DRV_Reg32(g_rmem_off));
//printf(" rootfs (0x%x) = 0x%x\n",g_rmem_off+0x4,DRV_Reg32(g_rmem_off+0x4));
//printf(" rootfs (0x%x) = 0x%x\n",g_rmem_off+0x8,DRV_Reg32(g_rmem_off+0x8)); 


//*************
//* specify the kernel jumping address
//* 
  theKernel = (void (*)(int, int, uint)) (g_kmem_off);
//printf("\n > kernel mem offset (not include header) = 0x%x\n",theKernel);


//*************
//* specify the rootfs starting address
//* 
  initrd_start = g_rmem_off;
  initrd_end = initrd_start + g_rimg_sz;  
//printf(" > rootfs mem offset (not include header) = 0x%x\n\n",initrd_start);


#ifdef CONFIG_INITRD_TAG
	if (initrd_start && initrd_end)
	  setup_initrd_tag (bd, initrd_start, initrd_end);
#endif
#if CONFIG_VIDEOLFB_TAG
	setup_videolfb_tag ((gd_t *) gd);
#endif
	setup_end_tag (bd);
#endif


#ifdef CFG_UBOOT_PROFILING
  printf("[PROFILE] ------- do_nand_boot takes %d ms -------- \n", get_timer(time_do_nand_boot));
  printf("[MBOOT] ------- UBoot boot kernel takes %d ms -------- \n", get_timer(boot_time));
#endif

  printf("NAND BOOT\n");
#ifdef CONFIG_LCD
  video_printf("NAND BOOT\n");
  video_printf("Boot Linux Kernel\n");   	
#endif

	//*****************
	//* to centralize deinit process, moving 
	//* "Uboot_power_saving" to "cleanup_before_linux"
	//*
	cleanup_before_linux();

	printf(" > kernel mem offset (not include header) = 0x%x\n",theKernel);


	//*****************
	//* jump to kernel
	//*
	theKernel (0, bd->bi_arch_number, bd->bi_boot_params);
	return 0;
} 
 

#if defined (CONFIG_SETUP_MEMORY_TAGS) || \
    defined (CONFIG_CMDLINE_TAG) || \
    defined (CONFIG_INITRD_TAG) || \
    defined (CONFIG_SERIAL_TAG) || \
    defined (CONFIG_REVISION_TAG) || \
    defined (CONFIG_LCD) || \
    defined (CONFIG_VFD)
static void setup_start_tag (bd_t *bd)
{
	params = (struct tag *) bd->bi_boot_params;

	params->hdr.tag = ATAG_CORE;
	params->hdr.size = tag_size (tag_core);

	params->u.core.flags = 0;
	params->u.core.pagesize = 0;
	params->u.core.rootdev = 0;

	params = tag_next (params);
}


#ifdef CONFIG_SETUP_MEMORY_TAGS
static void setup_memory_tags (bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
		params->u.mem.size = bd->bi_dram[i].size;

		params = tag_next (params);
	}
}
static void setup_memory_tags_factory (bd_t *bd)//In factory mode, we meed to reserve 128M memory for 3D
{
	int i;
	int banks;
	
	banks = CONFIG_NR_DRAM_BANKS;
	
	if(banks == 1)
	{
	  params->hdr.tag = ATAG_MEM;
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
		params->u.mem.size = bd->bi_dram[i].size;
		
		params->u.mem.size -= 0x9600000;//reserve 150M for 3D

		params = tag_next (params);	  
	}
	else
	{
	  for (i = 0; i < banks; i++) {
  		params->hdr.tag = ATAG_MEM;
  		params->hdr.size = tag_size (tag_mem32);
  
  		params->u.mem.start = bd->bi_dram[i].start;
  		params->u.mem.size = bd->bi_dram[i].size;  		
  
      if(i == (banks-1))//last rank
      {
        params->u.mem.size -= 0x9600000;//reserve 150M for 3D
      }
  
  		params = tag_next (params);
	  }
	}	
}
#endif /* CONFIG_SETUP_MEMORY_TAGS */


static void setup_commandline_tag (bd_t *bd, char *commandline)
{
	char *p;

	if (!commandline)
		return;

	/* eat leading white space */
	for (p = commandline; *p == ' '; p++);

	/* skip non-existent command lines so the kernel will still
	 * use its default command line.
	 */
	if (*p == '\0')
		return;

	params->hdr.tag = ATAG_CMDLINE;
	params->hdr.size =
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;

	strcpy (params->u.cmdline.cmdline, p);

    printf("kernel command line=%s\n", params->u.cmdline.cmdline);

	params = tag_next (params);
}


#ifdef CONFIG_INITRD_TAG
static void setup_initrd_tag (bd_t *bd, ulong initrd_start, ulong initrd_end)
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
	params->hdr.size = tag_size (tag_initrd);

	params->u.initrd.start = initrd_start;
	params->u.initrd.size = initrd_end - initrd_start;

	params = tag_next (params);
}
#endif /* CONFIG_INITRD_TAG */


//#if defined (CONFIG_VFD) || defined (CONFIG_LCD)
#if CONFIG_VIDEOLFB_TAG
//extern ulong calc_fbsize (void);
extern UINT32 mt65xx_disp_get_vram_size(void);
static void setup_videolfb_tag (gd_t *gd)
{
	/* An ATAG_VIDEOLFB node tells the kernel where and how large
	 * the framebuffer for video was allocated (among other things).
	 * Note that a _physical_ address is passed !
	 *
	 * We only use it to pass the address and size, the other entries
	 * in the tag_videolfb are not of interest.
	 */
	params->hdr.tag = ATAG_VIDEOLFB;
	params->hdr.size = tag_size (tag_videolfb);

	if(g_boot_mode == FACTORY_BOOT)
	{	  
	  params->u.videolfb.lfb_base = (u32) gd->fb_base - 0x9600000;
	  
	  memcpy((char *)(params->u.videolfb.lfb_base), (char *)gd->fb_base, mt65xx_disp_get_vram_size());
	  printf("[UBOOT]fb = %x\n", params->u.videolfb.lfb_base);
	}
	else
	{  
	  params->u.videolfb.lfb_base = (u32) gd->fb_base;
	}
	/* Fb size is calculated according to parameters for our panel
	 */
	//params->u.videolfb.lfb_size = calc_fbsize();
	params->u.videolfb.lfb_size = mt65xx_disp_get_vram_size();
	params = tag_next (params);
}
#endif /* CONFIG_VFD || CONFIG_LCD */

#ifdef CONFIG_SERIAL_TAG
void setup_serial_tag (struct tag **tmp)
{
	struct tag *params = *tmp;
	struct tag_serialnr serialnr;
	void get_board_serial(struct tag_serialnr *serialnr);

	get_board_serial(&serialnr);
	params->hdr.tag = ATAG_SERIAL;
	params->hdr.size = tag_size (tag_serialnr);
	params->u.serialnr.low = serialnr.low;
	params->u.serialnr.high= serialnr.high;
	params = tag_next (params);
	*tmp = params;
}
#endif

#ifdef CONFIG_REVISION_TAG
void setup_revision_tag(struct tag **in_params)
{
	u32 rev = 0;
	u32 get_board_rev(void);

	rev = get_board_rev();
	params->hdr.tag = ATAG_REVISION;
	params->hdr.size = tag_size (tag_revision);
	params->u.revision.rev = rev;
	params = tag_next (params);
}
#endif  /* CONFIG_REVISION_TAG */


static void setup_end_tag (bd_t *bd)
{
	params->hdr.tag = ATAG_NONE;
	params->hdr.size = 0;
}

void setup_boot_tag (BOOTMODE boot_mode)
{
	params->hdr.tag = ATAG_BOOT;
	params->hdr.size = tag_size (tag_boot);
	params->u.boot.bootmode = boot_mode;
	params = tag_next (params);

	printf("boot mode = %d\n",boot_mode);
}

void setup_meta_com_tag (META_COM_TYPE meta_com_type, unsigned int meta_com_id)
{
	params->hdr.tag = ATAG_META_COM;
	params->hdr.size = tag_size (tag_meta_com);
	params->u.meta_com.meta_com_type= meta_com_type;
    params->u.meta_com.meta_com_id= meta_com_id;
	params = tag_next (params);

	printf("meta com type = %d\n", meta_com_type);
  	printf("meta com id = %d\n", meta_com_id);
}


#endif /* CONFIG_SETUP_MEMORY_TAGS || CONFIG_CMDLINE_TAG || CONFIG_INITRD_TAG */
